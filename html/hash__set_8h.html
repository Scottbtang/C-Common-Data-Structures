<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LibCDS: /home/zsshen/Desktop/git-hub-code/C-Common-Data-Structures/include/container/hash_set.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LibCDS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hash__set_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hash_set.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The unordered set to store unique keys.  
<a href="#details">More...</a></p>

<p><a href="hash__set_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHashSet.html">HashSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation for hash set.  <a href="structHashSet.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3f18c37126779d3a8c5e05da64491c8e"><td class="memItemLeft" align="right" valign="top">typedef struct _HashSetData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#a3f18c37126779d3a8c5e05da64491c8e">HashSetData</a></td></tr>
<tr class="memdesc:a3f18c37126779d3a8c5e05da64491c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">HashSetData is the data type for the container private information.  <a href="#a3f18c37126779d3a8c5e05da64491c8e">More...</a><br/></td></tr>
<tr class="separator:a3f18c37126779d3a8c5e05da64491c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a16e1ba88032036d7fd93add6769cd7a0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#a16e1ba88032036d7fd93add6769cd7a0">HashSetInit</a> (<a class="el" href="structHashSet.html">HashSet</a> **ppObj)</td></tr>
<tr class="memdesc:a16e1ba88032036d7fd93add6769cd7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a>.  <a href="#a16e1ba88032036d7fd93add6769cd7a0">More...</a><br/></td></tr>
<tr class="separator:a16e1ba88032036d7fd93add6769cd7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceba9e2cf41208f9637ab1df23c62e4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#aceba9e2cf41208f9637ab1df23c62e4b">HashSetDeinit</a> (<a class="el" href="structHashSet.html">HashSet</a> **ppObj)</td></tr>
<tr class="memdesc:aceba9e2cf41208f9637ab1df23c62e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor for <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a>.  <a href="#aceba9e2cf41208f9637ab1df23c62e4b">More...</a><br/></td></tr>
<tr class="separator:aceba9e2cf41208f9637ab1df23c62e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa05d698a7c3f57d6cb908316a770fa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#a0fa05d698a7c3f57d6cb908316a770fa">HashSetAdd</a> (<a class="el" href="structHashSet.html">HashSet</a> *self, Key key, size_t size)</td></tr>
<tr class="memdesc:a0fa05d698a7c3f57d6cb908316a770fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key into the set.  <a href="#a0fa05d698a7c3f57d6cb908316a770fa">More...</a><br/></td></tr>
<tr class="separator:a0fa05d698a7c3f57d6cb908316a770fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d7f359f3b9c6b31660c72c987c42f0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#ab3d7f359f3b9c6b31660c72c987c42f0">HashSetFind</a> (<a class="el" href="structHashSet.html">HashSet</a> *self, Key key, size_t size)</td></tr>
<tr class="memdesc:ab3d7f359f3b9c6b31660c72c987c42f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the set contains the designated key.  <a href="#ab3d7f359f3b9c6b31660c72c987c42f0">More...</a><br/></td></tr>
<tr class="separator:ab3d7f359f3b9c6b31660c72c987c42f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f84161453ce14a4600fb1e49307a51f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#a6f84161453ce14a4600fb1e49307a51f">HashSetRemove</a> (<a class="el" href="structHashSet.html">HashSet</a> *self, Key key, size_t size)</td></tr>
<tr class="memdesc:a6f84161453ce14a4600fb1e49307a51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the designated key from the set.  <a href="#a6f84161453ce14a4600fb1e49307a51f">More...</a><br/></td></tr>
<tr class="separator:a6f84161453ce14a4600fb1e49307a51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac118a8c9a09d5879f5a2755cc3cb7b68"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#ac118a8c9a09d5879f5a2755cc3cb7b68">HashSetSize</a> (<a class="el" href="structHashSet.html">HashSet</a> *self)</td></tr>
<tr class="memdesc:ac118a8c9a09d5879f5a2755cc3cb7b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of stored unique keys.  <a href="#ac118a8c9a09d5879f5a2755cc3cb7b68">More...</a><br/></td></tr>
<tr class="separator:ac118a8c9a09d5879f5a2755cc3cb7b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f4c28d1ff6a6b96a1e62faebb93d39"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#a42f4c28d1ff6a6b96a1e62faebb93d39">HashSetIterate</a> (<a class="el" href="structHashSet.html">HashSet</a> *self, bool bReset, Key *pKey)</td></tr>
<tr class="memdesc:a42f4c28d1ff6a6b96a1e62faebb93d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through the set to retrieve each key.  <a href="#a42f4c28d1ff6a6b96a1e62faebb93d39">More...</a><br/></td></tr>
<tr class="separator:a42f4c28d1ff6a6b96a1e62faebb93d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a086c3dbcf81fa50b95498a400b3d9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#ad6a086c3dbcf81fa50b95498a400b3d9">HashSetSetDestroy</a> (<a class="el" href="structHashSet.html">HashSet</a> *self, void(*pFunc)(Key))</td></tr>
<tr class="memdesc:ad6a086c3dbcf81fa50b95498a400b3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the custom key resource clean method.  <a href="#ad6a086c3dbcf81fa50b95498a400b3d9">More...</a><br/></td></tr>
<tr class="separator:ad6a086c3dbcf81fa50b95498a400b3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1363a0b1f2f9ca0bbfec951f1afb67f7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#a1363a0b1f2f9ca0bbfec951f1afb67f7">HashSetSetHash</a> (<a class="el" href="structHashSet.html">HashSet</a> *self, uint32_t(*pFunc)(Key, size_t))</td></tr>
<tr class="memdesc:a1363a0b1f2f9ca0bbfec951f1afb67f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the custom hash function.  <a href="#a1363a0b1f2f9ca0bbfec951f1afb67f7">More...</a><br/></td></tr>
<tr class="separator:a1363a0b1f2f9ca0bbfec951f1afb67f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e734b7f8ec66af3f334294b0dde7710"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#a5e734b7f8ec66af3f334294b0dde7710">HashSetUnion</a> (<a class="el" href="structHashSet.html">HashSet</a> *pFst, <a class="el" href="structHashSet.html">HashSet</a> *pSnd, <a class="el" href="structHashSet.html">HashSet</a> **ppDst)</td></tr>
<tr class="memdesc:a5e734b7f8ec66af3f334294b0dde7710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform union operation for the designated two sets and create the result set.  <a href="#a5e734b7f8ec66af3f334294b0dde7710">More...</a><br/></td></tr>
<tr class="separator:a5e734b7f8ec66af3f334294b0dde7710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efd46cac55c3cf96f6005265fc55a7c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#a8efd46cac55c3cf96f6005265fc55a7c">HashSetIntersect</a> (<a class="el" href="structHashSet.html">HashSet</a> *pFst, <a class="el" href="structHashSet.html">HashSet</a> *pSnd, <a class="el" href="structHashSet.html">HashSet</a> **ppDst)</td></tr>
<tr class="memdesc:a8efd46cac55c3cf96f6005265fc55a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform intersection operation for the designated two sets and create the result set.  <a href="#a8efd46cac55c3cf96f6005265fc55a7c">More...</a><br/></td></tr>
<tr class="separator:a8efd46cac55c3cf96f6005265fc55a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb012c22892da0c924e6dc0e4df768a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__set_8h.html#aaeb012c22892da0c924e6dc0e4df768a">HashSetDifference</a> (<a class="el" href="structHashSet.html">HashSet</a> *pFst, <a class="el" href="structHashSet.html">HashSet</a> *pSnd, <a class="el" href="structHashSet.html">HashSet</a> **ppDst)</td></tr>
<tr class="memdesc:aaeb012c22892da0c924e6dc0e4df768a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform difference operation for the first source set against the second source set and create the result set.  <a href="#aaeb012c22892da0c924e6dc0e4df768a">More...</a><br/></td></tr>
<tr class="separator:aaeb012c22892da0c924e6dc0e4df768a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The unordered set to store unique keys. </p>

<p>Definition in file <a class="el" href="hash__set_8h_source.html">hash_set.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a3f18c37126779d3a8c5e05da64491c8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _HashSetData <a class="el" href="hash__set_8h.html#a3f18c37126779d3a8c5e05da64491c8e">HashSetData</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HashSetData is the data type for the container private information. </p>

<p>Definition at line <a class="el" href="hash__set_8h_source.html#l00011">11</a> of file <a class="el" href="hash__set_8h_source.html">hash_set.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a16e1ba88032036d7fd93add6769cd7a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> **&#160;</td>
          <td class="paramname"><em>ppObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructor for <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppObj</td><td>The double pointer to the to be constructed set</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SUCC</td><td></td></tr>
    <tr><td class="paramname">ERR_NOMEM</td><td>Insufficient memory for set construction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aceba9e2cf41208f9637ab1df23c62e4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HashSetDeinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> **&#160;</td>
          <td class="paramname"><em>ppObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The destructor for <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a>. </p>
<p>If the custom resource clean method is set, it also runs the clean method for each pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppObj</td><td>The double pointer to the to be destructed set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fa05d698a7c3f57d6cb908316a770fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a key into the set. </p>
<p>This function inserts a key into the set. If the designated key is the same with a certain one stored in the set, that key will be replaced to maintain the element uniqueness. Also, if the custom resource clean method is set, it runs the resource clean method for the replaced key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The pointer to <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a> structure </td></tr>
    <tr><td class="paramname">key</td><td>The designated key </td></tr>
    <tr><td class="paramname">size</td><td>Key size in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SUCC</td><td></td></tr>
    <tr><td class="paramname">ERR_NOINIT</td><td>Uninitialized container </td></tr>
    <tr><td class="paramname">ERR_NOMEM</td><td>Insufficient memory for set extension </td></tr>
    <tr><td class="paramname">ERR_KEYSIZE</td><td>Invalid key size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The key should be the pointer to the data you plan to hash for. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3d7f359f3b9c6b31660c72c987c42f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetFind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the set contains the designated key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The pointer to <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a> structure </td></tr>
    <tr><td class="paramname">key</td><td>The designated key </td></tr>
    <tr><td class="paramname">size</td><td>Key size in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SUCC</td><td>The key can be found </td></tr>
    <tr><td class="paramname">NOKEY</td><td>The key cannot be found </td></tr>
    <tr><td class="paramname">ERR_NOINIT</td><td>Uninitialized container </td></tr>
    <tr><td class="paramname">ERR_KEYSIZE</td><td>Invalid key size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The key should be the pointer to the data you plan to hash for. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f84161453ce14a4600fb1e49307a51f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetRemove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the designated key from the set. </p>
<p>This function deletes the designated key from the set. If the custom resource clean method is set, it also runs the clean method for the deleted key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The pointer to <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a> structure </td></tr>
    <tr><td class="paramname">key</td><td>The designated key </td></tr>
    <tr><td class="paramname">size</td><td>Key size in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SUCC</td><td></td></tr>
    <tr><td class="paramname">ERR_NOINIT</td><td>Uninitialized container </td></tr>
    <tr><td class="paramname">ERR_NODATA</td><td>No set entry can be found </td></tr>
    <tr><td class="paramname">ERR_KEYSIZE</td><td>Invalid key size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The key should be the pointer to the data you plan to hash for. </dd></dl>

</div>
</div>
<a class="anchor" id="ac118a8c9a09d5879f5a2755cc3cb7b68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of stored unique keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The pointer to <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a> structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of stored pairs </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_NOINIT</td><td>Uninitialized container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42f4c28d1ff6a6b96a1e62faebb93d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetIterate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bReset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>pKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate through the set to retrieve each key. </p>
<p>Before iterating through the set, it is necessary to pass:</p>
<ul>
<li>bReset = true</li>
<li>pKey = NULL for iterator initialization.</li>
</ul>
<p>After initialization, you can pass:</p>
<ul>
<li>bReset = false</li>
<li>pKey = the pointer to get the returned key at each iteration.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The pointer to <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a> structure </td></tr>
    <tr><td class="paramname">bReset</td><td>The knob to restart the iteration </td></tr>
    <tr><td class="paramname">pKey</td><td>The pointer to the returned key</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SUCC</td><td>Iterator initialized successfully </td></tr>
    <tr><td class="paramname">CONTINUE</td><td>Iteration in progress </td></tr>
    <tr><td class="paramname">END</td><td>Iteration terminated </td></tr>
    <tr><td class="paramname">ERR_NOINIT</td><td>Uninitialized container </td></tr>
    <tr><td class="paramname">ERR_GET</td><td>Invalid parameter to store returned key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Please do not insert or delete keys during set traversal </dd></dl>

</div>
</div>
<a class="anchor" id="ad6a086c3dbcf81fa50b95498a400b3d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetSetDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(Key)&#160;</td>
          <td class="paramname"><em>pFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the custom key resource clean method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The pointer to <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a> structure </td></tr>
    <tr><td class="paramname">pFunc</td><td>The function pointer to the custom method</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SUCC</td><td></td></tr>
    <tr><td class="paramname">ERR_NOINIT</td><td>Uninitialized container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1363a0b1f2f9ca0bbfec951f1afb67f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetSetHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t(*)(Key, size_t)&#160;</td>
          <td class="paramname"><em>pFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the custom hash function. </p>
<p>The default hash function is HashMurMur32.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The pointer to <a class="el" href="structHashSet.html" title="The implementation for hash set. ">HashSet</a> structure </td></tr>
    <tr><td class="paramname">pFunc</td><td>The function pointer to the custom method</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SUCC</td><td></td></tr>
    <tr><td class="paramname">ERR_NOINIT</td><td>Uninitialized container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e734b7f8ec66af3f334294b0dde7710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>pFst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>pSnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> **&#160;</td>
          <td class="paramname"><em>ppDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform union operation for the designated two sets and create the result set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFst</td><td>The pointer to the first source set </td></tr>
    <tr><td class="paramname">pSnd</td><td>The pointer to the second source set </td></tr>
    <tr><td class="paramname">ppDst</td><td>The double pointer to the to be created result set</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SUCC</td><td></td></tr>
    <tr><td class="paramname">ERR_NOINIT</td><td>Uninitialized source sets </td></tr>
    <tr><td class="paramname">ERR_NOMEM</td><td>Insufficient memory for new set creation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The newly created set will not delegate any key resource clean methods from two source sets. You can still set the clean method for it. However, to avoid the "double-free" problem, it is better to let the source sets handle the resource clean issue and treat the new set as the pure result from the union operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a8efd46cac55c3cf96f6005265fc55a7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>pFst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>pSnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> **&#160;</td>
          <td class="paramname"><em>ppDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform intersection operation for the designated two sets and create the result set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFst</td><td>The pointer to the first source set </td></tr>
    <tr><td class="paramname">pSnd</td><td>The pointer to the second source set </td></tr>
    <tr><td class="paramname">ppDst</td><td>The double pointer to the to be created result set</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SUCC</td><td></td></tr>
    <tr><td class="paramname">ERR_NOINIT</td><td>Uninitialized source sets </td></tr>
    <tr><td class="paramname">ERR_NOMEM</td><td>Insufficient memory for new set creation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The newly created set will not delegate any key resource clean methods from two source sets. You can still set the clean method for it. However, to avoid the "double-free" problem, it is better to let the source sets handle the resource clean issue and treat the new set as the pure result from the intersection operation. </dd></dl>

</div>
</div>
<a class="anchor" id="aaeb012c22892da0c924e6dc0e4df768a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t HashSetDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>pFst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> *&#160;</td>
          <td class="paramname"><em>pSnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHashSet.html">HashSet</a> **&#160;</td>
          <td class="paramname"><em>ppDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform difference operation for the first source set against the second source set and create the result set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFst</td><td>The pointer to the first source set </td></tr>
    <tr><td class="paramname">pSnd</td><td>The pointer to the second source set </td></tr>
    <tr><td class="paramname">ppDst</td><td>The double pointer to the to be created result set</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SUCC</td><td></td></tr>
    <tr><td class="paramname">ERR_NOINIT</td><td>Uninitialized source sets </td></tr>
    <tr><td class="paramname">ERR_NOMEM</td><td>Insufficient memory for new set creation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The newly created set will not delegate any key resource clean methods from two source sets. You can still set the clean method for it. However, to avoid the "double-free" problem, it is better to let the source sets handle the resource clean issue and treat the new set as the pure result from the difference operation. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_e0f5f6345e438c73b9ae78ec2940718c.html">container</a></li><li class="navelem"><a class="el" href="hash__set_8h.html">hash_set.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
